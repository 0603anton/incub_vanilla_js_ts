const students = [
    {
        name: "Bob",
        age: 22,
        isMarried: true,
        scores: 85,
    },
    {
        name: "Alex",
        age: 21,
        isMarried: true,
        scores: 90,
    },
    {
        name: "Nick",
        age: 20,
        isMarried: false,
        scores: 120,
    },
    {
        name: "John",
        age: 19,
        isMarried: false,
        scores: 100,
    },
    {
        name: "Helen",
        age: 20,
        isMarried: false,
        scores: 110,
    },
    {
        name: "Ann",
        age: 20,
        isMarried: false,
        scores: 105,
    },
];

const user = {
    name: "Bob",
    age: 23,
    isMarried: false,
    friends: ["Alex", "Nick", "John"],
};

//1. Поверхностная копия user + проверка

//2. Полная (глубокая) копия user + проверка

//3. Поверхностная копия students

//4*. Полная (глубокая) копия students

//Далее все преобразования выполняем не модифицируя исходный массив students

//5. Отсортируйте студентов по успеваемости (лучший идёт первым)

//5a. Отсортируйте студентов по алфавиту ( ,jkmit vtymit + local compare c sort)

//6a. Сформируйте массив из трёх лучших студентов slice/splice


//6b. Объедините массивы deepCopyStudents и topStudents так,
// чтоб сохранился порядок сортировки - тут просто соед через деструктуризацию или concat

//7. Сформируйте массив холостых студентов

//8. Сформируйте массив имён студентов

//8a. Сформируйте строку из имён студентов, разделённых
// - пробелом
// - запятой

//9. Добавьте всем студентам свойство "isStudent" со значением true

//10. Nick женился. Выполните преобразование массива students

//11. Найдите Студентку по имени Ann (find or filter) - почитай ещё, что лучше

//12. Найдите студента с самым высоким баллом (всё же подскажу reduce)

//12a. Найдите 2 студента с самым высоким баллом - тут что-то не понял как
// решали, но мой обходной путь отсортировать и выбрать 2 начальных значения
// без вложенных циклов - но прочитай и понял, пока с подсказкой сделай так
// делаем 2 переменных лучСтуд и лучСтуд1 присваиваем 2 первых значения списка студентов
// и цикл по всему массиву, если очки 1> больше очков второго то делаем перебор массива и присваиваем наибольшее значение 2 студенту
// если наоборот и первый студ с меньшими очками, то перебор массива и присваиваем наибольшее значение
// первому студенту

// и там ещё вариант короче его напамять

//13. Найдите сумму баллов всех студентов

// 14.Напишите функцию addFriends, которая принимает
// параметром массив students и возвращает новый массив, при этом добавляет
// в каждому студенту свойство .friends, значением которого является массив имён
// всех остальных студентов из
// массива, за исключением собственного имени студента. Т.е. в друзьях у Боба Боба быть не должно.